{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello, I'm Pedakolimi Harish \ud83d\udc4b","text":"<p>A Robotics Enthusiast | ROS Developer | Innovator | Mentor</p>"},{"location":"#technology-is-best-when-it-brings-people-together-matt-mullenweg","title":"\u201cTechnology is best when it brings people together.\u201d \u2013 Matt Mullenweg","text":""},{"location":"#my-mission","title":"My Mission","text":"<p>I aim to revolutionize the field of robotics by creating secure, modular, and accessible systems that empower individuals and industries alike.</p>"},{"location":"#about-me","title":"About Me","text":"<p>I'm a passionate Engineer with over 3 years of experience in robotics. Currently pursuing a Master's in Applied Mechatronics and Robotics at IIT Bhilai, I specialize in creating innovative solutions that bridge the gap between software and hardware.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Developed algorithms for optimizing robotic arm trajectories in 3D printing applications.</li> <li>Creator of Humble Robots, an open-source ROS2 learning platform.</li> <li>Designed Yantrik Hast, a compact 6-DOF robotic arm tailored for videographers.</li> </ul>"},{"location":"#skills-at-a-glance","title":"Skills at a Glance","text":"<ul> <li>Robotics: ROS/ROS2, MoveIt2, 3D Printing, Motion Planning</li> <li>Programming: Python, C, C++</li> <li>Platforms: Raspberry Pi, Arduino, ESP32, STM32</li> <li>Software: AutoCAD, Fusion 360, Gazebo</li> <li>Specializations: Navigation Stack, Digital Twins, OpenCV</li> </ul>"},{"location":"#recent-updates","title":"Recent Updates","text":"<ul> <li>\ud83d\udcd8 Publishing a guide on ROS2 Humble for beginners.</li> <li>\ud83e\udd16 Currently developing Yantrik Hast, a robotic arm for videography.</li> <li>\ud83c\udf93 Leading workshops for undergraduates in robotics through Sure Trust.</li> </ul>"},{"location":"#fun-facts-about-me","title":"Fun Facts About Me","text":"<ul> <li>\ud83c\udf0d I love exploring the intersection of technology and sustainability.</li> <li>\ud83c\udfae Avid gamer and enthusiast for strategy games.</li> <li>\ud83d\udcf7 Passionate about photography and capturing the beauty of nature.</li> </ul>"},{"location":"#contact-me","title":"Contact Me","text":"<p>Feel free to connect via: - \ud83d\udce7 Email Me - \ud83d\udee0 LinkedIn - \ud83e\uddd1\u200d\ud83d\udcbb GitHub</p>"},{"location":"about/","title":"About Me","text":"<p>Resume</p>"},{"location":"about/#career-timeline-with-job-details","title":"Career Timeline with Job Details","text":""},{"location":"about/#kelvin6k-technologies-private-limited-chennai-apr-2024-present","title":"Kelvin6k Technologies Private Limited \u2013 Chennai (Apr 2024 \u2013 Present)","text":"<ul> <li>Conceptualize, develop, and deploy ROS-based software solutions geared towards orchestrating the movements of our SCARA robotic arm in the realm of 3D construction printing applications.</li> <li>Foster collaboration with hardware engineers to seamlessly fuse software functionalities with hardware components, ensuring flawless integration and peak performance of the robotic arm.</li> <li>Engineer algorithms and execute motion planning techniques to optimize the trajectory of the robotic arm, aiming for precision and efficiency in 3D printing endeavors.</li> <li>Innovate by designing and developing fresh web interfaces and machine language code specific to 3D printing, while also programming user-friendly Human-Machine Interfaces (HMIs) for motion control systems.</li> </ul>"},{"location":"about/#mentor-sure-trust-wfh-present","title":"Mentor \u2013 Sure Trust \u2013 WFH (Present)","text":"<ul> <li>Guide and support undergraduates in understanding and applying robotics concepts through hands-on learning and practical exercises.</li> <li>Teach essential robotics principles, fostering a deep understanding of theoretical and practical aspects, including programming, mechanics, and electronics.</li> <li>Dedicate time and expertise on a voluntary basis, contributing to the academic and professional growth of students passionate about robotics.</li> </ul>"},{"location":"about/#jr-robotics-engineer-ai-bar-wfh-dec-2021-oct-2023","title":"Jr. Robotics Engineer \u2013 AI BAR \u2013 WFH (Dec 2021 \u2013 Oct 2023)","text":"<ul> <li>Designed, executed, and validated cutting-edge features and algorithms in ROS, ensuring seamless integration into the robotic systems</li> <li>Successfully integrated, tested, and debugged software solutions in simulation environments nd on tangible robotic platforms</li> <li>Collaborated effectively with cross-functional teams including software developers, hardware engineers, operations personnel, and other stakeholders</li> <li>Building protypes for different robots and IoT devices</li> <li>Demonstrated leadership skills by mentoring and guiding fellow members of the robotics team in achieving their professional development goals</li> </ul>"},{"location":"about/#intern-hind-robo-hyderabad-aug-2021-dec-2021","title":"Intern \u2013 HIND ROBO \u2013 Hyderabad (Aug 2021 \u2013 Dec 2021)","text":"<ul> <li>Developed engaging and easily comprehensible course content for children.</li> <li>Demonstrated creativity and innovation by designing remarkable Arduino projects.</li> <li>Assessed and resolved issues by thoroughly testing and debugging various projects.</li> <li>Strategically selected suitable components for each project.</li> <li>Utilized CAD software proficiently to construct precise 3D printer models.</li> </ul>"},{"location":"about/#intern-cems-centre-of-excellence-in-maritime-and-shipbuilding-visakhapatnam-may-2019-jun-2019","title":"Intern \u2013 C.E.M.S (Centre of Excellence in Maritime and Shipbuilding) \u2013 Visakhapatnam (May 2019 \u2013 Jun 2019)","text":"<ul> <li>Acquired an understanding of the programming, software, and maintenance of the KUKA industrial robots.</li> <li>worked on three industrial robots designed and built by KUKA.</li> <li>Since I was the sole intern, I had exclusive duties and insights regarding the material-handling robot, plasma cutting, and MiG welding robot.</li> <li>I was the top pupil at the time.</li> </ul>"},{"location":"about/#intern-defence-research-and-development-organization-drdo-bhubaneswar-may-2018-jun-2018","title":"Intern \u2013 Defence Research and Development Organization (DRDO) \u2013 Bhubaneswar (May 2018 \u2013 Jun 2018)","text":"<ul> <li>Gained practical knowledge working on cooling systems and components of a radar system.</li> <li>Maintained and worked on the communication system of the radar base.</li> <li>Researched and explored new areas of engineering within the organization.</li> </ul>"},{"location":"about/#education-timeline","title":"Education Timeline","text":"<pre><code>graph TD\n    A[2016-2020: B.Tech, Mechanical Engineering&lt;br&gt;GITAM University] --&gt;\n    B[2024-2026: Masters, APPLIED MECHATRONICS AND ROBOTICS Engineering&lt;br&gt;IIT Bhilai]</code></pre>"},{"location":"Notes/Getting%20Started/","title":"Notes","text":"<p>hellwo</p>"},{"location":"Notes/Physics/Getting%20Started/","title":"Physics","text":""},{"location":"Notes/Programming/C/c/","title":"c","text":""},{"location":"Notes/Programming/C%2B%2B/cpp/","title":"cpp","text":""},{"location":"Notes/Programming/Python/python/","title":"python","text":""},{"location":"Notes/Programming/Rust/rust/","title":"rust","text":""},{"location":"Notes/ROS2/Basics/Node/","title":"Nodes in ROS 2","text":"<p>Each node in ROS should be responsible for a single, modular purpose, e.g. controlling the wheel motors or publishing the sensor data from a laser range-finder. Each node can send and receive data from other nodes via topics, services, actions, or parameters.</p> <p>A full robotic system is comprised of many nodes working in concert. In ROS 2, a single executable (C++ program, Python program, etc.) can contain one or more nodes.</p> <p>Note</p> <p>to run thi you have to install turtlesim onto your ros2</p>"},{"location":"Notes/ROS2/Basics/Node/#ros2-run","title":"ros2 run","text":"<p>The command ros2 run launches an executable from a package.</p> Bash<pre><code>ros2 run &lt;package_name&gt; &lt;executable_name&gt;\n</code></pre> <p>To run turtlesim, open a new terminal, and enter the following command:</p> Bash<pre><code>ros2 run turtlesim turtlesim_node\n</code></pre> <p>The turtlesim window will open, as you saw in the previous tutorial.</p> <p>Here, the package name is turtlesim and the executable name is turtlesim_node.</p> <p>We still don\u2019t know the node name, however. You can find node names by using ros2 node list</p>"},{"location":"Notes/ROS2/Basics/Node/#ros2-node-list","title":"ros2 node list","text":"<p>ros2 node list will show you the names of all running nodes. This is especially useful when you want to interact with a node, or when you have a system running many nodes and need to keep track of them.</p> <p>Open a new terminal while turtlesim is still running in the other one, and enter the following command:</p> Bash<pre><code>ros2 node list\n</code></pre> <p>The terminal will return the node name:</p> Bash<pre><code>/turtlesim\n</code></pre> <p>Open another new terminal and start the teleop node with the command:</p> Bash<pre><code>ros2 run turtlesim turtle_teleop_key\n</code></pre> <p>Here, we are referring to the turtlesim package again, but this time we target the executable named turtle_teleop_key.</p> <p>Return to the terminal where you ran ros2 node list and run it again. You will now see the names of two active nodes: Bash<pre><code>/turtlesim\n/teleop_turtle\n</code></pre></p>"},{"location":"Notes/ROS2/Basics/Node/#remapping","title":"Remapping","text":"<p>Remapping allows you to reassign default node properties, like node name, topic names, service names, etc., to custom values. In the last tutorial, you used remapping on turtle_teleop_key to change the cmd_vel topic and target turtle2.</p> <p>Now, let\u2019s reassign the name of our <code>/turtlesim</code> node. In a new terminal, run the following command:</p> Bash<pre><code>ros2 run turtlesim turtlesim_node --ros-args --remap __node:=my_turtle\n</code></pre> <p>Since you\u2019re calling ros2 run on turtlesim again, another turtlesim window will open. However, now if you return to the terminal where you ran ros2 node list, and run it again, you will see three node names:</p> Bash<pre><code>/my_turtle\n/turtlesim\n/teleop_turtle\n</code></pre>"},{"location":"Notes/ROS2/Basics/Node/#ros2-node-info","title":"ros2 node info","text":"<p>Now that you know the names of your nodes, you can access more information about them with:</p> Bash<pre><code>ros2 node info &lt;node_name&gt;\n</code></pre> <p>To examine your latest node, my_turtle, run the following command:</p> Bash<pre><code>ros2 node info /my_turtle\n</code></pre> <p>ros2 node info returns a list of subscribers, publishers, services, and actions. i.e. the ROS graph connections that interact with that node. The output should look like this:</p> <p>Bash<pre><code>/my_turtle\n  Subscribers:\n    /parameter_events: rcl_interfaces/msg/ParameterEvent\n    /turtle1/cmd_vel: geometry_msgs/msg/Twist\n  Publishers:\n    /parameter_events: rcl_interfaces/msg/ParameterEvent\n    /rosout: rcl_interfaces/msg/Log\n    /turtle1/color_sensor: turtlesim/msg/Color\n    /turtle1/pose: turtlesim/msg/Pose\n  Service Servers:\n    /clear: std_srvs/srv/Empty\n    /kill: turtlesim/srv/Kill\n    /my_turtle/describe_parameters: rcl_interfaces/srv/DescribeParameters\n    /my_turtle/get_parameter_types: rcl_interfaces/srv/GetParameterTypes\n    /my_turtle/get_parameters: rcl_interfaces/srv/GetParameters\n    /my_turtle/list_parameters: rcl_interfaces/srv/ListParameters\n    /my_turtle/set_parameters: rcl_interfaces/srv/SetParameters\n    /my_turtle/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically\n    /reset: std_srvs/srv/Empty\n    /spawn: turtlesim/srv/Spawn\n    /turtle1/set_pen: turtlesim/srv/SetPen\n    /turtle1/teleport_absolute: turtlesim/srv/TeleportAbsolute\n    /turtle1/teleport_relative: turtlesim/srv/TeleportRelative\n  Service Clients:\n\n  Action Servers:\n    /turtle1/rotate_absolute: turtlesim/action/RotateAbsolute\n  Action Clients:\n</code></pre> Now try running the same command on the <code>/teleop_turtle</code> node, and see how its connections differ from my_turtle.</p> <p>You will learn more about the ROS graph connection concepts including the message types in the upcoming tutorials.</p>"},{"location":"Notes/ROS2/Basics/Node/#summary","title":"Summary","text":"<p>A node is a fundamental ROS 2 element that serves a single, modular purpose in a robotics system.</p> <p>In this tutorial, you utilized nodes created in the turtlesim package by running the executables turtlesim_node and turtle_teleop_key.</p> <p>You learned how to use ros2 node list to discover active node names and ros2 node info to introspect a single node. These tools are vital to understanding the flow of data in a complex, real-world robot system.</p>"},{"location":"Notes/ROS2/Basics/Topic/","title":"Topic","text":""},{"location":"Notes/ROS2/Getting%20Started/DDS%20and%20ROS_DOMAIN_ID/","title":"How DDS Works?","text":"<p>When you\u2019re working with robots, you need a way for all the different parts of the robot to talk to each other. That\u2019s where something called DDS comes in. DDS stands for Data Distribution Service, and it\u2019s like a super-advanced messaging system for robots and computers.</p> <p>Think of it like this: imagine you have a bunch of robots in a factory, and they all need to work together to build cars. Each robot has a specific job, like welding doors or painting bumpers. To do their jobs, they need to be able to send messages to each other, like \u201cI\u2019ve finished welding this door\u201d or \u201cI need more paint over here!\u201d</p> <p>DDS is what makes this communication possible. It is a set of rules that all the robots agree to follow so they can send messages quickly and reliably. It is kind of like a big chat room where robots can post and read messages, but instead of just being for fun, these messages contain important information that the robots need to do their jobs.</p> <p>ROS 2 uses DDS under the hood to help all the different parts of a robot communicate. You can think of DDS as the glue that holds everything together in a ROS 2 system.</p>"},{"location":"Notes/ROS2/Getting%20Started/DDS%20and%20ROS_DOMAIN_ID/#what-is-the-ros_domain_id","title":"What is the ROS_DOMAIN_ID?","text":"<p>Now, here\u2019s where something called the ROS_DOMAIN_ID comes in. In a DDS system, you can have multiple \u201cchat rooms,\u201d each with its own ID number. These \u201cchat rooms\u201d are called domains in DDS language. The ROS_DOMAIN_ID is just a number that tells ROS which domain to use.</p> <p>By default, ROS uses 0 for the ROS_DOMAIN_ID. It is fine if we keep the default since we are working in simulation. However, in the real world, you might have a facility with multiple robots, all running ROS 2. If all these robots use the default settings, they\u2019ll all be talking in the same \u201cchat room\u201d \u2013 domain 0. </p> <p>This is fine if you want all your robots to be able to communicate with each other. But let\u2019s say you have two different teams of robots in your factory, and you don\u2019t want them to get confused by hearing each other\u2019s messages. You could put one team in domain 1 and the other team in domain 2. They\u2019re all still using DDS to communicate, but the two teams can\u2019t hear each other because they\u2019re in different domains.</p> <p>The easiest way to choose a ROS_DOMAIN_ID is to pick a number between 0 and 101, or between 215 and 232. These numbers are less likely to conflict with other programs that might be using DDS.</p> <p>This means all our robots will be able to communicate with each other. But if you ever need to work with multiple groups of robots that shouldn\u2019t be talking to each other, remember that you can use different ROS_DOMAIN_IDs to keep their conversations separate.</p> <p>If you did want to change the ROS_DOMAIN_ID, you can do it by typing this command:</p> Bash<pre><code>export ROS_DOMAIN_ID=&lt;your_chosen_number&gt;\n</code></pre> <p>Replace <code>&lt;your_chosen_number&gt;</code> with the ROS_DOMAIN_ID you want to use. For example, if you want to use a ROS_DOMAIN_ID of 42, you would add in the terminal window before the commands you want to run:</p> Bash<pre><code>export ROS_DOMAIN_ID=42\n</code></pre> <p>Remember, if you have multiple robots on the same WiFi network and you want them to be able to talk to each other, they should all have the same ROS_DOMAIN_ID. But if you have groups of robots that shouldn\u2019t be communicating, give each group its own ROS_DOMAIN_ID.</p> <p>Example Let\u2019s look at an example:</p> <p>Open a new terminal, and type this:</p> Bash<pre><code>ros2 run demo_nodes_cpp talker\n</code></pre> <p>This \u201ctalker\u201d program publishes messages to the ROS 2 system. </p> <p>Open another terminal window, and type:</p> Bash<pre><code>ros2 run demo_nodes_py listener\n</code></pre> <p>You can see both programs are able to talk to each other freely because they have the same ROS_DOMAIN_IDs.</p> <p>Now close both nodes by pressing CTRL+C in both terminal windows.</p> <p>Now in a the first terminal window, type this:</p> Bash<pre><code>export ROS_DOMAIN_ID=8\n</code></pre> <p>In that same terminal window, type:</p> Bash<pre><code>ros2 run demo_nodes_cpp talker\n</code></pre> <p>Now in your second terminal window, type:</p> Bash<pre><code>ros2 run demo_nodes_py listener\n</code></pre> <p>You can see this node can\u2019t receive messages from the other node.</p> <p>You can now close this listener using CTRL + C.</p> <p>Now set the ROS_DOMAIN_ID to match our publisher node.</p> Bash<pre><code>export ROS_DOMAIN_ID=8\nros2 run demo_nodes_py listener\n</code></pre> <p>You can see now that, since these nodes have the same ROS_DOMAIN_ID, they can now communicate with each other. </p> <p>That\u2019s it. I\u2019ll see you in the next tutorial. Keep building!</p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/","title":"Ros2 Installation Guide","text":"<p>How to install ROS2 Jazzy</p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#requirement","title":"Requirement","text":"<p>Working ubuntu 24.04 LTS, It depends on you how you want to install it like WSL2, VM, Dual Boot or Direct install</p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#ros2-installation","title":"Ros2 Installation","text":"<p>Official setup guild will be available in Ros2 Jazzy, automaticaddison jazzy setup. You follow that too mostly everything is same.</p> <p>We will begin by installing ROS 2 Jazzy via Debian Packages. Debian packages are software files used to install programs and applications on Ubuntu.</p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#setup-locale","title":"Setup Locale","text":"<p>Open a new terminal window.</p> <p>Type this command inside a terminal window.</p> Bash<pre><code>locale\n</code></pre> <p>If you see something like this that means you already have locale ready to use, but if you don't then follow along.</p> Bash<pre><code>LANG=en_US.UTF-8\nLANGUAGE=\nLC_CTYPE=\"en_US.UTF-8\"\nLC_NUMERIC=\"en_US.UTF-8\"\nLC_TIME=\"en_US.UTF-8\"\nLC_COLLATE=\"en_US.UTF-8\"\nLC_MONETARY=\"en_US.UTF-8\"\nLC_MESSAGES=\"en_US.UTF-8\"\nLC_PAPER=\"en_US.UTF-8\"\nLC_NAME=\"en_US.UTF-8\"\nLC_ADDRESS=\"en_US.UTF-8\"\nLC_TELEPHONE=\"en_US.UTF-8\"\nLC_MEASUREMENT=\"en_US.UTF-8\"\nLC_IDENTIFICATION=\"en_US.UTF-8\"\nLC_ALL=\n</code></pre> <p>A locale is a set of variables that define the language, country, and character encoding settings. These settings are used by applications to determine how to display text, dates, times, and other information.</p> <p>Now type the following command:</p> Bash<pre><code>sudo apt update &amp;&amp; sudo apt install locales\n</code></pre> <p><code>sudo apt update</code> updates the package index list. This list is a database of all the software packages available for your version of Ubuntu.</p> <p><code>sudo apt install locales</code> installs the locales package, which provides support for different languages and regions.</p> <p>Now type the following commands into the terminal window to generate locale definition files. After each command, press Enter only your keyboard:</p> Bash<pre><code>sudo locale-gen en_US en_US.UTF-8\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nexport LANG=en_US.UTF-8\n</code></pre> <p>In this case, these commands are generating locale definition files for the English (United States) locale and the English (United States) UTF-8 locale. The UTF-8 locale is a special locale that supports the UTF-8 character encoding, which is the standard encoding for most languages.</p> <p>Now we need to verify the settings by typing:</p> Bash<pre><code>locale\n</code></pre> <p>After installing these you will see the following</p> Bash<pre><code>LANG=en_US.UTF-8\nLANGUAGE=\nLC_CTYPE=\"en_US.UTF-8\"\nLC_NUMERIC=\"en_US.UTF-8\"\nLC_TIME=\"en_US.UTF-8\"\nLC_COLLATE=\"en_US.UTF-8\"\nLC_MONETARY=\"en_US.UTF-8\"\nLC_MESSAGES=\"en_US.UTF-8\"\nLC_PAPER=\"en_US.UTF-8\"\nLC_NAME=\"en_US.UTF-8\"\nLC_ADDRESS=\"en_US.UTF-8\"\nLC_TELEPHONE=\"en_US.UTF-8\"\nLC_MEASUREMENT=\"en_US.UTF-8\"\nLC_IDENTIFICATION=\"en_US.UTF-8\"\nLC_ALL=\n</code></pre>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#enable-the-required-repositories","title":"Enable the Required Repositories","text":"<p>Let\u2019s add the ROS 2 apt repository to our system. APT stands for \u201cAdvanced Package Repository\u201d. This repository provides a convenient way to install and manage ROS 2 packages without having to clone packages to your computer from GitHub and build them from that source code.  </p> <p>Open a terminal window, and type the following two commands:</p> <p>Bash<pre><code>sudo apt install software-properties-common\nsudo add-apt-repository universe\n</code></pre> Press Enter.</p> <p>The software-properties-common package provides a number of tools for managing software sources on Ubuntu and Debian systems. </p> <p>The universe repository is a software repository that contains a wide variety of software packages, including many that are not included in the default Ubuntu and Debian repositories. </p> <p>Now we need to add the ROS 2 GPG key with apt. The ROS 2 GPG key makes sure the software packages you are installing are from a trusted source.</p> <p>Type these two commands:</p> Bash<pre><code>sudo apt update &amp;&amp; sudo apt install curl -y\nsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\n</code></pre> <p>Add the repository to your sources list (copy and paste all of this below):</p> Bash<pre><code>echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2-testing/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n</code></pre> <p>Type the following command to install ROS 2 development tools.</p> Bash<pre><code>sudo apt update &amp;&amp; sudo apt install ros-dev-tools\n</code></pre> <p>Now update the apt repository:</p> Bash<pre><code>sudo apt update -y\n</code></pre> <p>Upgrade the packages on your system to make sure you have the newest versions.</p> Bash<pre><code>sudo apt upgrade -y\n</code></pre>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#install-ros-2","title":"Install ROS 2","text":"<p>Here is where we get to install ROS 2 Jazzy. </p> <p>Open a terminal window, and type this command:</p> <p>Desktop Install (Recommended): ROS, RViz, demos, tutorials.</p> Bash<pre><code>sudo apt install ros-jazzy-desktop\n</code></pre> <p>ROS-Base Install (Bare Bones): Communication libraries, message packages, command line tools. No GUI tools.</p> Bash<pre><code>sudo apt install ros-jazzy-ros-base\n</code></pre>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#set-up-the-environment-variables","title":"Set Up the Environment Variables","text":"<p>Once jazzy has finished installing, you need to set up the important environment variables. Environment variables are settings that tell your computer how to find and use ROS 2 commands and packages.</p> <p>Open a terminal window, and type this command:</p> Bash<pre><code>echo \"source /opt/ros/jazzy/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre> <p>When you run this command, it appends the line source <code>/opt/ros/jazzy/setup.bash</code> to your <code>~/.bashrc</code> file. </p> <p>What does this do? Each time you open a new terminal window, you are starting what is called a bash session. The bash session needs to know what version of ROS 2 you are using. </p> <p>By adding this line <code>(echo \u201csource /opt/ros/jazzy/setup.bash\u201d)</code> to your <code>~/.bashrc</code> file, you ensure the necessary environment variables and paths for ROS 2 Jazzy are properly set up each time you open a new terminal window, allowing you to use ROS 2 commands and tools without having to manually run the setup.bash script every time.</p> <p>For the changes to take effect, you now need to open a new terminal window, or you can type this command in the current terminal:</p> Bash<pre><code>source ~/.bashrc\n</code></pre> <p>You can verify that line was added by typing:</p> Bash<pre><code>cd\nnano .bashrc\n</code></pre> <p>and at the end you will see </p> Bash<pre><code>source /opt/ros/jazzy/setup.bash\n</code></pre>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#install-gazebo-and-other-useful-packages","title":"Install Gazebo and Other Useful Packages","text":"<p>Let\u2019s install some other useful packages like pip (the Python package manager), Gazebo, a simulation software for robotics, and NumPy, a scientific computing library for Python.</p> Bash<pre><code>sudo apt-get install python3 python3-pip -y\nsudo apt-get install ros-${ROS_DISTRO}-ros-gz -y\nsudo apt-get install python3-numpy\n</code></pre> <p>Let\u2019s make these environment variables permanent. Open a terminal window, and type these commands, one after the other:</p> Bash<pre><code>echo 'export LIBGL_ALWAYS_SOFTWARE=1' &gt;&gt; ~/.bashrc\necho 'export QT_QPA_PLATFORM=xcb' &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#test-your-gazebo-installation","title":"Test your Gazebo Installation","text":"<p>open a new terminal window, and type:</p> Bash<pre><code>gz sim -v 4 shapes.sdf\n</code></pre> <p>You should see something like this</p> gazebo shapes.sdf <p>This command will launch gazebo  Bash<pre><code>gz sim \n</code></pre></p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#test-your-ros-2-installation","title":"Test Your ROS 2 Installation.","text":"<p>Now that we have tested Gazebo, let\u2019s test our ROS 2 installation by running some sample programs.</p> <p>Open a terminal window, and type:</p> Bash<pre><code>ros2 run demo_nodes_cpp talker\n</code></pre> demo_talker <p>This command runs a pre-built program called \u201ctalker\u201d that comes with ROS 2. The \u201ctalker\u201d program publishes messages to the ROS 2 system in string format. </p> <p>Open another terminal window, and type:</p> Bash<pre><code>ros2 run demo_nodes_py listener\n</code></pre> demo_listener <p>If your output looks similar to the images above, you have installed ROS 2 successfully. </p> <p>To close these programs, press CTRL + C on your keyboard in both terminal windows.</p> <p>Now you have installed Ros2 Jazzy and Gazebo Harmonic successfully, now go learn more about ros2.</p>"},{"location":"Notes/ROS2/Getting%20Started/Ros2%20installation%20guide/#uninstall","title":"Uninstall","text":"<p>If you need to uninstall ROS 2 or switch to a source-based install once you have already installed from binaries, run the following command:</p> Bash<pre><code>sudo apt remove ~nros-jazzy-* &amp;&amp; sudo apt autoremove\n</code></pre> <p>You may also want to remove the repository:</p> Bash<pre><code>sudo rm /etc/apt/sources.list.d/ros2.list\nsudo apt update\nsudo apt autoremove\n# Consider upgrading for packages previously shadowed.\nsudo apt upgrade\n</code></pre>"}]}